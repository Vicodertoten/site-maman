---
// RecipeFilters.astro - Filtres complets pour les recettes
export interface Props {
  currentFilters?: {
    search?: string;
    category?: string | string[];
    difficulty?: string | string[];
    time?: string | string[];
    budget?: string | string[];
    tags?: string[];
    diet?: string[];
    season?: string[];
    sort?: string;
  };
  availableTags?: string[];
  availableDiets?: Array<{ value: string; label: string }>;
  availableSeasons?: Array<{ value: string; label: string }>;
  categories?: Array<{ value: string; label: string; count?: number }>;
  budgets?: Array<{ value: string; label: string }>;
  totalRecipes: number;
}

const {
  currentFilters = {},
  availableTags = [],
  availableDiets = [],
  availableSeasons = [],
  categories = [],
  budgets = [],
  totalRecipes
} = Astro.props;
---

<div class="recipe-filters mv-card p-6 mb-8">
  <div class="flex flex-col lg:flex-row gap-4">
    <div class="flex-1">
      <label for="recipe-search" class="block text-sm font-medium text-mv-forest mb-2">
        Rechercher une recette
      </label>
      <div class="relative">
        <svg class="absolute left-3 top-1/2 -translate-y-1/2 h-5 w-5 text-mv-forest-60" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"/>
        </svg>
        <input
          type="text"
          id="recipe-search"
          value={currentFilters.search || ''}
          placeholder="Nom, ingrédient, tag..."
          class="mv-input mv-input--icon w-full"
        />
        <button
          id="clear-search"
          class="absolute right-3 top-1/2 -translate-y-1/2 text-mv-forest-60 hover:text-mv-forest hidden"
          aria-label="Effacer la recherche"
        >
          <svg class="h-5 w-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
          </svg>
        </button>
      </div>
    </div>

    <div class="w-full lg:w-56">
      <label for="sort-filter" class="block text-sm font-medium text-mv-forest mb-2">
        Trier
      </label>
      <select
        id="sort-filter"
        class="filter-select mv-input w-full py-3"
      >
        <option value="recent">Plus récent</option>
        <option value="popular">Populaire</option>
        <option value="rating">Mieux noté</option>
        <option value="time">Temps total</option>
        <option value="difficulty">Difficulté</option>
        <option value="name">Nom (A-Z)</option>
      </select>
    </div>

    <div class="w-full lg:w-48 lg:self-end">
      <button
        id="filters-toggle"
        class="mv-btn mv-btn-secondary w-full border border-mv-leaf-30 text-mv-forest bg-white hover:border-mv-leaf hover:text-mv-leaf transition-colors focus:outline-none focus:ring-2 focus:ring-mv-leaf focus:ring-offset-2"
        type="button"
        aria-expanded="false"
      >
        <span>Filtres</span>
        <span id="filters-count" class="text-xs bg-mv-cream text-mv-forest px-2 py-0.5 rounded-full">0</span>
      </button>
    </div>
  </div>

  <div id="filters-panel" class="mt-6 grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 hidden">
    <div class="filter-dropdown" data-filter="category">
      <label class="block text-sm font-medium text-mv-forest mb-2">Catégorie</label>
      <button type="button" class="filter-trigger mv-input w-full flex items-center justify-between" aria-haspopup="true" aria-expanded="false" aria-controls="filter-menu-category">
        <span>Choisir</span>
        <span id="category-count" class="text-xs text-mv-forest-60">Tous</span>
      </button>
      <div id="filter-menu-category" class="filter-menu hidden" role="group" aria-label="Filtrer par catégorie">
        {categories.map((category) => (
          <label class="filter-option flex items-center gap-2 text-sm text-mv-forest">
            <input
              type="checkbox"
              class="filter-checkbox"
              data-filter="category"
              value={category.value}
              data-label={`${category.label}${category.count ? ` (${category.count})` : ''}`}
              checked={Array.isArray(currentFilters.category) ? currentFilters.category.includes(category.value) : currentFilters.category === category.value}
            />
            <span>{category.label}{category.count ? ` (${category.count})` : ''}</span>
          </label>
        ))}
      </div>
    </div>

    <div class="filter-dropdown" data-filter="difficulty">
      <label class="block text-sm font-medium text-mv-forest mb-2">Difficulté</label>
      <button type="button" class="filter-trigger mv-input w-full flex items-center justify-between" aria-haspopup="true" aria-expanded="false" aria-controls="filter-menu-difficulty">
        <span>Choisir</span>
        <span id="difficulty-count" class="text-xs text-mv-forest-60">Tous</span>
      </button>
      <div id="filter-menu-difficulty" class="filter-menu hidden" role="group" aria-label="Filtrer par difficulté">
        {['facile','moyen','difficile'].map((value) => (
          <label class="filter-option flex items-center gap-2 text-sm text-mv-forest">
            <input
              type="checkbox"
              class="filter-checkbox"
              data-filter="difficulty"
              value={value}
              data-label={value.charAt(0).toUpperCase() + value.slice(1)}
              checked={Array.isArray(currentFilters.difficulty) ? currentFilters.difficulty.includes(value) : currentFilters.difficulty === value}
            />
            <span>{value.charAt(0).toUpperCase() + value.slice(1)}</span>
          </label>
        ))}
      </div>
    </div>

    <div class="filter-dropdown" data-filter="time">
      <label class="block text-sm font-medium text-mv-forest mb-2">Temps total</label>
      <button type="button" class="filter-trigger mv-input w-full flex items-center justify-between" aria-haspopup="true" aria-expanded="false" aria-controls="filter-menu-time">
        <span>Choisir</span>
        <span id="time-count" class="text-xs text-mv-forest-60">Tous</span>
      </button>
      <div id="filter-menu-time" class="filter-menu hidden" role="group" aria-label="Filtrer par temps total">
        {[
          { value: '15', label: 'Moins de 15 min' },
          { value: '30', label: '15-30 min' },
          { value: '60', label: '30-60 min' },
          { value: '120', label: "Plus d'1h" }
        ].map((item) => (
          <label class="filter-option flex items-center gap-2 text-sm text-mv-forest">
            <input
              type="checkbox"
              class="filter-checkbox"
              data-filter="time"
              value={item.value}
              data-label={item.label}
              checked={Array.isArray(currentFilters.time) ? currentFilters.time.includes(item.value) : currentFilters.time === item.value}
            />
            <span>{item.label}</span>
          </label>
        ))}
      </div>
    </div>

    <div class="filter-dropdown" data-filter="budget">
      <label class="block text-sm font-medium text-mv-forest mb-2">Budget</label>
      <button type="button" class="filter-trigger mv-input w-full flex items-center justify-between" aria-haspopup="true" aria-expanded="false" aria-controls="filter-menu-budget">
        <span>Choisir</span>
        <span id="budget-count" class="text-xs text-mv-forest-60">Tous</span>
      </button>
      <div id="filter-menu-budget" class="filter-menu hidden" role="group" aria-label="Filtrer par budget">
        {budgets.map((budget) => (
          <label class="filter-option flex items-center gap-2 text-sm text-mv-forest">
            <input
              type="checkbox"
              class="filter-checkbox"
              data-filter="budget"
              value={budget.value}
              data-label={budget.label}
              checked={Array.isArray(currentFilters.budget) ? currentFilters.budget.includes(budget.value) : currentFilters.budget === budget.value}
            />
            <span>{budget.label}</span>
          </label>
        ))}
      </div>
    </div>
  </div>

  <div id="filters-advanced" class="mt-6 grid grid-cols-1 lg:grid-cols-3 gap-4 hidden">
    {availableTags.length > 0 && (
      <div class="filter-dropdown" data-filter="tags">
        <label class="block text-sm font-medium text-mv-forest mb-2">Tags</label>
        <button type="button" class="filter-trigger mv-input w-full flex items-center justify-between" aria-haspopup="true" aria-expanded="false" aria-controls="filter-menu-tags">
          <span>Choisir</span>
          <span id="tags-count" class="text-xs text-mv-forest-60">Tous</span>
        </button>
        <div id="filter-menu-tags" class="filter-menu hidden" role="group" aria-label="Filtrer par tags">
          {availableTags.map(tag => (
            <label class="filter-option flex items-center gap-2 text-sm text-mv-forest">
              <input
                type="checkbox"
                class="filter-checkbox"
                data-filter="tags"
                value={tag}
                data-label={`#${tag}`}
                checked={currentFilters.tags?.includes(tag)}
              />
              <span>#{tag}</span>
            </label>
          ))}
        </div>
      </div>
    )}
    {availableDiets.length > 0 && (
      <div class="filter-dropdown" data-filter="diet">
        <label class="block text-sm font-medium text-mv-forest mb-2">Régimes</label>
        <button type="button" class="filter-trigger mv-input w-full flex items-center justify-between" aria-haspopup="true" aria-expanded="false" aria-controls="filter-menu-diet">
          <span>Choisir</span>
          <span id="diet-count" class="text-xs text-mv-forest-60">Tous</span>
        </button>
        <div id="filter-menu-diet" class="filter-menu hidden" role="group" aria-label="Filtrer par régimes">
          {availableDiets.map(diet => (
            <label class="filter-option flex items-center gap-2 text-sm text-mv-forest">
              <input
                type="checkbox"
                class="filter-checkbox"
                data-filter="diet"
                value={diet.value}
                data-label={diet.label}
                checked={currentFilters.diet?.includes(diet.value)}
              />
              <span>{diet.label}</span>
            </label>
          ))}
        </div>
      </div>
    )}

    {availableSeasons.length > 0 && (
      <div class="filter-dropdown" data-filter="season">
        <label class="block text-sm font-medium text-mv-forest mb-2">Saisons</label>
        <button type="button" class="filter-trigger mv-input w-full flex items-center justify-between" aria-haspopup="true" aria-expanded="false" aria-controls="filter-menu-season">
          <span>Choisir</span>
          <span id="season-count" class="text-xs text-mv-forest-60">Tous</span>
        </button>
        <div id="filter-menu-season" class="filter-menu hidden" role="group" aria-label="Filtrer par saisons">
          {availableSeasons.map(season => (
            <label class="filter-option flex items-center gap-2 text-sm text-mv-forest">
              <input
                type="checkbox"
                class="filter-checkbox"
                data-filter="season"
                value={season.value}
                data-label={season.label}
                checked={currentFilters.season?.includes(season.value)}
              />
              <span>{season.label}</span>
            </label>
          ))}
        </div>
      </div>
    )}
  </div>

  <div class="mt-6 flex flex-col lg:flex-row lg:items-center justify-between gap-4 border-t border-mv-leaf-20 pt-4">
    <div class="text-sm text-mv-forest-80">
      <span id="results-count">0</span> recette(s) trouvée(s) sur {totalRecipes}
    </div>

    <div id="active-filters" class="flex flex-wrap gap-2"></div>

    <button
      id="clear-filters"
      class="mv-btn mv-btn-secondary bg-mv-cream text-mv-forest hover:bg-mv-leaf-10 transition-colors focus:outline-none focus:ring-2 focus:ring-mv-leaf focus:ring-offset-2 disabled:opacity-50"
      disabled
    >
      Tout effacer
    </button>
  </div>
</div>

<script define:vars={{ currentFilters }}>
  const normalizeText = (value = '') =>
    (value ?? '')
      .toString()
      .toLowerCase()
      .normalize('NFD')
      .replace(/[\u0300-\u036f]/g, '')
      .trim();

  const difficultyOrder = { facile: 1, moyen: 2, difficile: 3 };

  const filterState = {
    search: currentFilters.search || '',
    category: currentFilters.category ? [currentFilters.category].flat().filter(Boolean) : [],
    difficulty: currentFilters.difficulty ? [currentFilters.difficulty].flat().filter(Boolean) : [],
    time: currentFilters.time ? [currentFilters.time].flat().filter(Boolean) : [],
    budget: currentFilters.budget ? [currentFilters.budget].flat().filter(Boolean) : [],
    tags: currentFilters.tags || [],
    diet: currentFilters.diet || [],
    season: currentFilters.season || [],
    sort: currentFilters.sort || 'recent'
  };

  const readJSONData = () => {
    if (Array.isArray(window.recipeIndex)) {
      return window.recipeIndex;
    }
    const el = document.getElementById('recipes-index');
    if (!el) return [];
    try {
      return JSON.parse(el.textContent || '[]');
    } catch (error) {
      console.error('Impossible de lire l\'index des recettes', error);
      return [];
    }
  };

  const parseURLFilters = () => {
    const params = new URLSearchParams(window.location.search);
    return {
      search: params.get('search') || '',
      category: params.get('category') ? params.get('category').split(',').filter(Boolean) : [],
      difficulty: params.get('difficulty') ? params.get('difficulty').split(',').filter(Boolean) : [],
      time: params.get('time') ? params.get('time').split(',').filter(Boolean) : [],
      budget: params.get('budget') ? params.get('budget').split(',').filter(Boolean) : [],
      tags: params.get('tags') ? params.get('tags').split(',').filter(Boolean) : [],
      diet: params.get('diet') ? params.get('diet').split(',').filter(Boolean) : [],
      season: params.get('season') ? params.get('season').split(',').filter(Boolean) : [],
      sort: params.get('sort') || 'recent'
    };
  };

  const buildRecipeIndex = (recipes) => recipes.map(recipe => {
    const totalTime = (recipe.prepTime || 0) + (recipe.cookTime || 0) + (recipe.restTime || 0);
    const tags = Array.isArray(recipe.tags) ? recipe.tags : [];
    const diet = Array.isArray(recipe.diet) ? recipe.diet : [];
    const season = Array.isArray(recipe.season) ? recipe.season : [];
    const ingredients = Array.isArray(recipe.ingredients) ? recipe.ingredients : [];
    const ingredientNames = typeof recipe.ingredientText === 'string'
      ? recipe.ingredientText
      : ingredients.map((ing) => (typeof ing === 'string' ? ing : ing.name)).join(' ');

    return {
      ...recipe,
      totalTime,
      _search: normalizeText([recipe.title, recipe.description, ingredientNames, tags.join(' '), diet.join(' '), season.join(' ')].join(' ')),
      _tags: tags.map(normalizeText),
      _diet: diet.map(normalizeText),
      _season: season.map(normalizeText)
    };
  });

  const applyURLFilters = () => {
    const urlFilters = parseURLFilters();
    Object.assign(filterState, urlFilters);
  };

  const updateURL = () => {
    const params = new URLSearchParams();

    if (filterState.search) params.set('search', filterState.search);
    if (filterState.category.length) params.set('category', filterState.category.join(','));
    if (filterState.difficulty.length) params.set('difficulty', filterState.difficulty.join(','));
    if (filterState.time.length) params.set('time', filterState.time.join(','));
    if (filterState.budget.length) params.set('budget', filterState.budget.join(','));
    if (filterState.tags.length) params.set('tags', filterState.tags.join(','));
    if (filterState.diet.length) params.set('diet', filterState.diet.join(','));
    if (filterState.season.length) params.set('season', filterState.season.join(','));
    if (filterState.sort && filterState.sort !== 'recent') params.set('sort', filterState.sort);

    const query = params.toString();
    const newUrl = query ? `${window.location.pathname}?${query}` : window.location.pathname;
    window.history.replaceState({}, '', newUrl);
  };

  const sortRecipes = (recipes) => {
    return recipes.sort((a, b) => {
      switch (filterState.sort) {
        case 'name':
          return a.title.localeCompare(b.title);
        case 'time':
          return (a.totalTime || 0) - (b.totalTime || 0);
        case 'difficulty':
          return (difficultyOrder[a.difficulty] || 99) - (difficultyOrder[b.difficulty] || 99);
        case 'rating':
          return (b.rating || 0) - (a.rating || 0);
        case 'popular':
          return (b.isPopular ? 1 : 0) - (a.isPopular ? 1 : 0) || (b.rating || 0) - (a.rating || 0);
        case 'recent':
        default:
          return new Date(b.publishedAt || 0).getTime() - new Date(a.publishedAt || 0).getTime();
      }
    });
  };

  const matchesFilters = (recipe) => {
    if (filterState.search) {
      const term = normalizeText(filterState.search);
      if (!recipe._search.includes(term)) return false;
    }

    if (filterState.category.length > 0) {
      const selected = filterState.category.map(normalizeText);
      if (!selected.includes(normalizeText(recipe.category))) return false;
    }
    if (filterState.difficulty.length > 0) {
      const selected = filterState.difficulty.map(normalizeText);
      if (!selected.includes(normalizeText(recipe.difficulty))) return false;
    }
    if (filterState.budget.length > 0) {
      const selected = filterState.budget.map(normalizeText);
      if (!selected.includes(normalizeText(recipe.budget))) return false;
    }

    if (filterState.time.length > 0) {
      const total = recipe.totalTime || 0;
      const matchesAny = filterState.time.some((value) => {
        switch (value) {
          case '15':
            return total < 15;
          case '30':
            return total >= 15 && total < 30;
          case '60':
            return total >= 30 && total < 60;
          case '120':
            return total >= 60;
          default:
            return true;
        }
      });
      if (!matchesAny) return false;
    }

    if (filterState.tags.length > 0) {
      const selectedTags = filterState.tags.map(normalizeText);
      const hasTag = selectedTags.some((tag) => recipe._tags.includes(tag));
      if (!hasTag) return false;
    }

    if (filterState.diet.length > 0) {
      const selected = filterState.diet.map(normalizeText);
      const hasDiet = selected.some((diet) => recipe._diet.includes(diet));
      if (!hasDiet) return false;
    }

    if (filterState.season.length > 0) {
      const selected = filterState.season.map(normalizeText);
      const hasSeason = selected.some((season) => recipe._season.includes(season));
      if (!hasSeason) return false;
    }

    return true;
  };

  const updateActiveFilters = () => {
    const container = document.getElementById('active-filters');
    if (!container) return;
    container.innerHTML = '';

    const addChip = (label, onRemove) => {
      const button = document.createElement('button');
      button.type = 'button';
      button.className = 'mv-chip hover:bg-mv-leaf hover:text-mv-cream transition-colors';
      button.textContent = label;
      button.addEventListener('click', onRemove);
      container.appendChild(button);
    };

    const getInputLabel = (selector, value) => {
      const input = Array.from(document.querySelectorAll(selector)).find((el) => el.value === value);
      return input?.dataset?.label || input?.textContent || value;
    };

    if (filterState.search) {
      addChip(`Recherche: ${filterState.search}`, () => {
        filterState.search = '';
        document.getElementById('recipe-search').value = '';
        applyFilters();
      });
    }

    filterState.category.forEach((value) => {
      addChip(getInputLabel(`.filter-checkbox[data-filter="category"][value="${value}"]`, value), () => {
        filterState.category = filterState.category.filter((item) => item !== value);
        const checkbox = document.querySelector(`.filter-checkbox[data-filter="category"][value="${value}"]`);
        if (checkbox) checkbox.checked = false;
        applyFilters();
      });
    });

    filterState.difficulty.forEach((value) => {
      addChip(getInputLabel(`.filter-checkbox[data-filter="difficulty"][value="${value}"]`, value), () => {
        filterState.difficulty = filterState.difficulty.filter((item) => item !== value);
        const checkbox = document.querySelector(`.filter-checkbox[data-filter="difficulty"][value="${value}"]`);
        if (checkbox) checkbox.checked = false;
        applyFilters();
      });
    });

    filterState.time.forEach((value) => {
      addChip(getInputLabel(`.filter-checkbox[data-filter="time"][value="${value}"]`, value), () => {
        filterState.time = filterState.time.filter((item) => item !== value);
        const checkbox = document.querySelector(`.filter-checkbox[data-filter="time"][value="${value}"]`);
        if (checkbox) checkbox.checked = false;
        applyFilters();
      });
    });

    filterState.budget.forEach((value) => {
      addChip(getInputLabel(`.filter-checkbox[data-filter="budget"][value="${value}"]`, value), () => {
        filterState.budget = filterState.budget.filter((item) => item !== value);
        const checkbox = document.querySelector(`.filter-checkbox[data-filter="budget"][value="${value}"]`);
        if (checkbox) checkbox.checked = false;
        applyFilters();
      });
    });

    filterState.tags.forEach((tag) => {
      addChip(`#${tag}`, () => {
        filterState.tags = filterState.tags.filter((value) => value !== tag);
        const checkbox = document.querySelector(`.filter-checkbox[data-filter="tags"][value="${tag}"]`);
        if (checkbox) checkbox.checked = false;
        applyFilters();
      });
    });

    filterState.diet.forEach((diet) => {
      addChip(getInputLabel(`.filter-checkbox[data-filter="diet"][value="${diet}"]`, diet), () => {
        filterState.diet = filterState.diet.filter((value) => value !== diet);
        const checkbox = document.querySelector(`.filter-checkbox[data-filter="diet"][value="${diet}"]`);
        if (checkbox) checkbox.checked = false;
        applyFilters();
      });
    });

    filterState.season.forEach((season) => {
      addChip(getInputLabel(`.filter-checkbox[data-filter="season"][value="${season}"]`, season), () => {
        filterState.season = filterState.season.filter((value) => value !== season);
        const checkbox = document.querySelector(`.filter-checkbox[data-filter="season"][value="${season}"]`);
        if (checkbox) checkbox.checked = false;
        applyFilters();
      });
    });
  };

  const updateClearButton = () => {
    const clearBtn = document.getElementById('clear-filters');
    const hasFilters = Boolean(
      filterState.search ||
      filterState.category.length ||
      filterState.difficulty.length ||
      filterState.time.length ||
      filterState.budget.length ||
      filterState.tags.length ||
      filterState.diet.length ||
      filterState.season.length
    );
    clearBtn.disabled = !hasFilters;

    const countBadge = document.getElementById('filters-count');
    if (countBadge) {
      const count =
        (filterState.search ? 1 : 0) +
        filterState.category.length +
        filterState.difficulty.length +
        filterState.time.length +
        filterState.budget.length +
        filterState.tags.length +
        filterState.diet.length +
        filterState.season.length;
      countBadge.textContent = count.toString();
    }

    const updateCount = (id, count) => {
      const el = document.getElementById(id);
      if (!el) return;
      el.textContent = count ? `${count} sélection` : 'Tous';
    };

    updateCount('category-count', filterState.category.length);
    updateCount('difficulty-count', filterState.difficulty.length);
    updateCount('time-count', filterState.time.length);
    updateCount('budget-count', filterState.budget.length);
    updateCount('tags-count', filterState.tags.length);
    updateCount('diet-count', filterState.diet.length);
    updateCount('season-count', filterState.season.length);
  };

  let recipeIndex = [];
  let cardsById = new Map();
  let grid = null;
  let emptyState = null;
  let loadMoreButton = null;
  let autoLoadSentinel = null;
  let autoLoadObserver = null;
  let autoLoadedSteps = 0;
  let lastTotalRecipes = 0;
  let lastDisplayedRecipes = 0;
  let autoLoadInProgress = false;
  const DEFAULT_PAGE_SIZE = 10;
  const MAX_AUTO_LOAD_STEPS = 9;
  let visibleRecipesLimit = DEFAULT_PAGE_SIZE;

  const mergeById = (base = [], incoming = []) => {
    const map = new Map();
    base.forEach((recipe) => {
      if (recipe?.id) map.set(recipe.id, recipe);
    });
    incoming.forEach((recipe) => {
      if (recipe?.id) map.set(recipe.id, recipe);
    });
    return Array.from(map.values());
  };

  const hasActiveFilters = () => Boolean(
    filterState.search ||
    filterState.category.length ||
    filterState.difficulty.length ||
    filterState.time.length ||
    filterState.budget.length ||
    filterState.tags.length ||
    filterState.diet.length ||
    filterState.season.length
  );

  const ensureCardForRecipe = (recipe, index = 0) => {
    const existing = cardsById.get(recipe.id);
    if (existing) return existing;
    if (!grid || typeof window.renderRecipeCard !== 'function') return null;

    const wrapper = document.createElement('div');
    wrapper.className = `scroll-fade-in ${index % 2 === 0 ? 'scroll-slide-in-left' : 'scroll-slide-in-right'}`;
    wrapper.style.animationDelay = `${Math.min(index, 18) * 0.05}s`;
    wrapper.dataset.recipeCard = '';
    wrapper.dataset.recipeId = recipe.id;
    wrapper.innerHTML = window.renderRecipeCard(recipe);
    grid.appendChild(wrapper);
    cardsById.set(recipe.id, wrapper);
    return wrapper;
  };

  const updateLoadMoreButton = (totalRecipes, displayedRecipes) => {
    lastTotalRecipes = totalRecipes;
    lastDisplayedRecipes = displayedRecipes;
    if (!loadMoreButton) return;
    const showPagination = !hasActiveFilters();
    const hasMore = displayedRecipes < totalRecipes;

    loadMoreButton.classList.toggle('hidden', !hasMore);
    loadMoreButton.disabled = !hasMore;
    loadMoreButton.textContent = hasMore
      ? `Charger plus (${displayedRecipes}/${totalRecipes})`
      : 'Tout est chargé';

    if (autoLoadSentinel) {
      const canAutoLoad = showPagination && hasMore && autoLoadedSteps < MAX_AUTO_LOAD_STEPS;
      autoLoadSentinel.classList.toggle('hidden', !canAutoLoad);
    }
  };

  const loadMorePage = (source = 'manual') => {
    visibleRecipesLimit += DEFAULT_PAGE_SIZE;
    if (source === 'auto') {
      autoLoadedSteps += 1;
    }
    applyFilters();
  };

  const renderCards = (recipes) => {
    if (!grid) return;
    const shouldPaginate = !hasActiveFilters();
    const displayedRecipes = shouldPaginate ? recipes.slice(0, visibleRecipesLimit) : recipes;
    const fragment = document.createDocumentFragment();
    const visibleIds = new Set();

    displayedRecipes.forEach((recipe, index) => {
      const card = ensureCardForRecipe(recipe, index);
      if (!card) return;
      visibleIds.add(recipe.id);
      card.classList.remove('hidden');
      fragment.appendChild(card);
    });

    cardsById.forEach((card, id) => {
      if (!visibleIds.has(id)) {
        card.classList.add('hidden');
      }
    });

    grid.appendChild(fragment);

    if (emptyState) {
      emptyState.classList.toggle('hidden', displayedRecipes.length !== 0);
    }

    updateLoadMoreButton(recipes.length, displayedRecipes.length);
  };

  const updateResultsCount = (count) => {
    const resultsCount = document.getElementById('results-count');
    resultsCount.textContent = count.toString();
  };

  const applyFilters = () => {
    const filtered = recipeIndex.filter(matchesFilters);
    const sorted = sortRecipes(filtered);

    updateResultsCount(sorted.length);
    updateActiveFilters();
    updateClearButton();
    updateURL();
    renderCards(sorted);

    window.dispatchEvent(new CustomEvent('recipesFiltered', {
      detail: { recipes: sorted, filters: { ...filterState } }
    }));
  };

  const bindEvents = () => {
    const searchInput = document.getElementById('recipe-search');
    const clearSearchBtn = document.getElementById('clear-search');
    const sortSelect = document.getElementById('sort-filter');
    const filtersPanel = document.getElementById('filters-panel');
    const filtersAdvanced = document.getElementById('filters-advanced');
    const filtersToggle = document.getElementById('filters-toggle');
    loadMoreButton = document.getElementById('recipes-load-more');
    autoLoadSentinel = document.getElementById('recipes-auto-load-sentinel');
    const resetPagination = () => {
      visibleRecipesLimit = DEFAULT_PAGE_SIZE;
      autoLoadedSteps = 0;
    };
    const closeAllMenus = () => {
      document.querySelectorAll('.filter-menu').forEach((panel) => panel.classList.add('hidden'));
      document.querySelectorAll('.filter-trigger').forEach((button) => button.setAttribute('aria-expanded', 'false'));
    };

    const openMenu = (dropdown) => {
      if (!dropdown) return;
      const trigger = dropdown.querySelector('.filter-trigger');
      const menu = dropdown.querySelector('.filter-menu');
      if (!trigger || !menu) return;
      closeAllMenus();
      menu.classList.remove('hidden');
      trigger.setAttribute('aria-expanded', 'true');
      const firstInput = menu.querySelector('input');
      if (firstInput && typeof firstInput.focus === 'function') firstInput.focus();
    };

    const debounce = (fn, delay = 300) => {
      let timeout;
      return (...args) => {
        clearTimeout(timeout);
        timeout = setTimeout(() => fn(...args), delay);
      };
    };

    searchInput.addEventListener('input', debounce(() => {
      filterState.search = searchInput.value.trim();
      clearSearchBtn.classList.toggle('hidden', !filterState.search);
      resetPagination();
      applyFilters();
    }));

    clearSearchBtn.addEventListener('click', () => {
      searchInput.value = '';
      filterState.search = '';
      clearSearchBtn.classList.add('hidden');
      resetPagination();
      applyFilters();
    });

    sortSelect.addEventListener('change', () => {
      filterState.sort = sortSelect.value;
      resetPagination();
      applyFilters();
    });

    document.querySelectorAll('.filter-checkbox').forEach((checkbox) => {
      checkbox.addEventListener('change', () => {
        const key = checkbox.dataset.filter;
        if (!key || !filterState[key]) return;
        const checkedValues = Array.from(document.querySelectorAll(`.filter-checkbox[data-filter="${key}"]`))
          .filter((input) => input.checked)
          .map((input) => input.value);
        filterState[key] = checkedValues;
        resetPagination();
        applyFilters();
      });
    });

    document.querySelectorAll('.filter-trigger').forEach((trigger) => {
      trigger.addEventListener('click', (event) => {
        event.preventDefault();
        const dropdown = trigger.closest('.filter-dropdown');
        if (!dropdown) return;
        const menu = dropdown.querySelector('.filter-menu');
        if (!menu) return;
        const isOpen = !menu.classList.contains('hidden');
        if (isOpen) {
          closeAllMenus();
        } else {
          openMenu(dropdown);
        }
      });

      trigger.addEventListener('keydown', (event) => {
        const dropdown = trigger.closest('.filter-dropdown');
        if (!dropdown) return;
        if (event.key === 'ArrowDown' || event.key === 'Enter' || event.key === ' ') {
          event.preventDefault();
          openMenu(dropdown);
        } else if (event.key === 'Escape') {
          event.preventDefault();
          closeAllMenus();
          trigger.focus();
        }
      });
    });

    document.querySelectorAll('.filter-menu').forEach((menu) => {
      menu.addEventListener('keydown', (event) => {
        const inputs = Array.from(menu.querySelectorAll('input'));
        if (!inputs.length) return;
        const activeIndex = inputs.indexOf(document.activeElement);

        if (event.key === 'Escape') {
          event.preventDefault();
          closeAllMenus();
          const dropdown = menu.closest('.filter-dropdown');
          const trigger = dropdown?.querySelector('.filter-trigger');
          if (trigger && typeof trigger.focus === 'function') trigger.focus();
          return;
        }

        if (event.key === 'ArrowDown') {
          event.preventDefault();
          const next = inputs[(activeIndex + 1) % inputs.length];
          if (next) next.focus();
        } else if (event.key === 'ArrowUp') {
          event.preventDefault();
          const prev = inputs[(activeIndex - 1 + inputs.length) % inputs.length];
          if (prev) prev.focus();
        }
      });
    });

    document.addEventListener('click', (event) => {
      const target = event.target;
      if (target.closest('.filter-dropdown')) return;
      closeAllMenus();
    });

    if (filtersToggle) {
      filtersToggle.addEventListener('click', () => {
        const isHidden = filtersPanel.classList.contains('hidden');
        filtersPanel.classList.toggle('hidden', !isHidden);
        filtersAdvanced.classList.toggle('hidden', !isHidden);
        filtersToggle.setAttribute('aria-expanded', isHidden ? 'true' : 'false');
      });
    }

    document.getElementById('clear-filters').addEventListener('click', () => {
      filterState.search = '';
      filterState.category = [];
      filterState.difficulty = [];
      filterState.time = [];
      filterState.budget = [];
      filterState.tags = [];
      filterState.diet = [];
      filterState.season = [];
      filterState.sort = 'recent';
      resetPagination();

      searchInput.value = '';
      clearSearchBtn.classList.add('hidden');
      sortSelect.value = 'recent';
      document.querySelectorAll('.filter-checkbox').forEach((checkbox) => {
        checkbox.checked = false;
      });

      applyFilters();
    });

    if (loadMoreButton) {
      loadMoreButton.addEventListener('click', () => {
        loadMorePage('manual');
      });
    }

    if (autoLoadSentinel && typeof IntersectionObserver !== 'undefined') {
      autoLoadObserver = new IntersectionObserver((entries) => {
        const [entry] = entries;
        if (!entry?.isIntersecting) return;
        if (autoLoadInProgress) return;
        const hasMore = lastDisplayedRecipes < lastTotalRecipes;
        const canAutoLoad = !hasActiveFilters() && hasMore && autoLoadedSteps < MAX_AUTO_LOAD_STEPS;
        if (!canAutoLoad) return;

        autoLoadInProgress = true;
        loadMorePage('auto');
        window.requestAnimationFrame(() => {
          autoLoadInProgress = false;
        });
      }, {
        root: null,
        rootMargin: '240px 0px',
        threshold: 0
      });

      autoLoadObserver.observe(autoLoadSentinel);
    }
  };

  const syncUI = () => {
    document.getElementById('recipe-search').value = filterState.search || '';
    document.getElementById('clear-search').classList.toggle('hidden', !filterState.search);
    document.getElementById('sort-filter').value = filterState.sort || 'recent';
    document.querySelectorAll('.filter-checkbox').forEach((checkbox) => {
      const key = checkbox.dataset.filter;
      if (!key || !filterState[key]) return;
      checkbox.checked = filterState[key].includes(checkbox.value);
    });
  };

  const fetchPublicIndex = async () => {
    try {
      const response = await fetch('/api/recipes');
      if (!response.ok) return;
      const payload = await response.json();
      if (!Array.isArray(payload?.recipes)) return;

      window.recipeIndex = mergeById(window.recipeIndex || [], payload.recipes);
      recipeIndex = buildRecipeIndex(window.recipeIndex);
      applyFilters();
    } catch (error) {
      console.error("Impossible de charger l'index recettes", error);
    }
  };

  window.addEventListener('recipesIndexUpdated', (event) => {
    const updated = event?.detail?.recipes;
    if (!Array.isArray(updated)) return;
    window.recipeIndex = mergeById(window.recipeIndex || [], updated);
    recipeIndex = buildRecipeIndex(window.recipeIndex);
    const cards = document.querySelectorAll('[data-recipe-card]');
    cardsById = new Map(Array.from(cards).map((card) => [card.dataset.recipeId, card]));
    applyFilters();
  });

  document.addEventListener('DOMContentLoaded', () => {
    applyURLFilters();

    window.recipeIndex = Array.isArray(window.recipeIndex) ? window.recipeIndex : readJSONData();
    recipeIndex = buildRecipeIndex(window.recipeIndex || []);
    grid = document.getElementById('recipes-grid');
    emptyState = document.getElementById('recipes-empty');

    const cards = document.querySelectorAll('[data-recipe-card]');
    cardsById = new Map(Array.from(cards).map((card) => [card.dataset.recipeId, card]));

    // If the server did not render cards (e.g., build-time fetch failed), create lightweight fallback cards from the index
    if (cardsById.size === 0 && recipeIndex.length > 0 && grid) {
      console.warn('No server-rendered recipe cards found — creating client-side fallback cards from recipes index.');

      const createFallbackCard = (recipe) => {
        const wrapper = document.createElement('div');
        wrapper.className = 'scroll-fade-in';
        wrapper.style.animationDelay = '0s';
        wrapper.setAttribute('data-recipe-card', '');
        wrapper.setAttribute('data-recipe-id', recipe.id);

        const safeText = (value) => (value ?? '').toString();
        const safeUrl = (value) => {
          const raw = (value ?? '').toString().trim();
          if (!raw) return '';
          if (raw.startsWith('/') && !raw.startsWith('//')) return raw;
          if (raw.startsWith('#')) return raw;
          if (/^https?:\/\//i.test(raw)) return raw;
          return '';
        };

        const article = document.createElement('article');
        article.className = 'mv-card group relative p-6';

        const imageWrapper = document.createElement('div');
        imageWrapper.className = 'relative z-20 overflow-hidden rounded-lg mb-4 pointer-events-none';

        const imageUrl = safeUrl(recipe.image);
        if (imageUrl) {
          const img = document.createElement('img');
          img.src = imageUrl;
          img.alt = safeText(recipe.title) || 'Recette';
          img.className = 'w-full h-48 object-cover group-hover:scale-105 transition-transform duration-300';
          img.loading = 'lazy';
          img.decoding = 'async';
          img.width = 400;
          img.height = 300;
          img.setAttribute('sizes', '(min-width: 1024px) 33vw, (min-width: 640px) 50vw, 100vw');
          imageWrapper.appendChild(img);
        } else {
          const placeholder = document.createElement('div');
          placeholder.className = 'w-full h-48 bg-gradient-to-br from-mv-cream to-mv-leaf flex items-center justify-center';
          placeholder.innerHTML = '<svg class="w-12 h-12 text-mv-forest opacity-50" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"/></svg>';
          imageWrapper.appendChild(placeholder);
        }

        const body = document.createElement('div');
        body.className = 'relative z-20 space-y-3 pointer-events-none';

        const textBlock = document.createElement('div');
        const title = document.createElement('h3');
        title.className = 'text-lg font-semibold text-mv-forest';
        title.textContent = safeText(recipe.title);
        textBlock.appendChild(title);
        if (recipe.description) {
          const desc = document.createElement('p');
          desc.className = 'text-sm text-mv-forest-80';
          desc.textContent = safeText(recipe.description);
          textBlock.appendChild(desc);
        }
        body.appendChild(textBlock);

        const meta = document.createElement('div');
        meta.className = 'flex items-center justify-between text-sm text-mv-forest-70';
        const totalTime = (recipe.prepTime || 0) + (recipe.cookTime || 0) + (recipe.restTime || 0);
        const time = document.createElement('div');
        time.textContent = totalTime ? `⏱️ ${totalTime} min` : '';
        const servings = document.createElement('div');
        servings.textContent = recipe.servings ? `${recipe.servings} pers.` : '';
        meta.appendChild(time);
        meta.appendChild(servings);
        body.appendChild(meta);

        article.appendChild(imageWrapper);
        article.appendChild(body);
        const anchor = document.createElement('a');
        anchor.href = `/recette/${encodeURIComponent(recipe.slug || recipe.id)}`;
        anchor.className = 'absolute inset-0 z-10 rounded-xl focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-mv-leaf focus-visible:ring-offset-2';
        anchor.setAttribute('aria-label', `Voir la recette ${safeText(recipe.title)}`);
        const anchorText = document.createElement('span');
        anchorText.className = 'sr-only';
        anchorText.textContent = `Voir la recette ${safeText(recipe.title)}`;
        anchor.appendChild(anchorText);
        article.appendChild(anchor);
        wrapper.appendChild(article);
        return wrapper;
      };

      recipeIndex.forEach((r) => {
        const card = createFallbackCard(r);
        grid.appendChild(card);
        cardsById.set(r.id, card);
      });
    }

    const sanitizeFilters = () => {
      const checkboxValues = (key) =>
        new Set(
          Array.from(document.querySelectorAll(`.filter-checkbox[data-filter="${key}"]`))
            .map((input) => input.value)
            .filter(Boolean)
        );

      const categoryValues = checkboxValues('category');
      const difficultyValues = checkboxValues('difficulty');
      const timeValues = checkboxValues('time');
      const budgetValues = checkboxValues('budget');
      const tagValues = checkboxValues('tags');
      const dietValues = checkboxValues('diet');
      const seasonValues = checkboxValues('season');
      const sortValues = new Set(['recent', 'popular', 'rating', 'time', 'difficulty', 'name']);

      filterState.category = filterState.category.filter((value) => categoryValues.has(value));
      filterState.difficulty = filterState.difficulty.filter((value) => difficultyValues.has(value));
      filterState.time = filterState.time.filter((value) => timeValues.has(value));
      filterState.budget = filterState.budget.filter((value) => budgetValues.has(value));
      if (filterState.sort && !sortValues.has(filterState.sort)) filterState.sort = 'recent';

      filterState.tags = filterState.tags.filter((tag) => tagValues.has(tag));
      filterState.diet = filterState.diet.filter((diet) => dietValues.has(diet));
      filterState.season = filterState.season.filter((season) => seasonValues.has(season));
    };

    sanitizeFilters();
    syncUI();
    bindEvents();
    applyFilters();
    fetchPublicIndex();
  });
</script>

<style>
  .filter-dropdown {
    position: relative;
  }

  .filter-trigger {
    cursor: pointer;
  }

  .filter-menu {
    position: absolute;
    top: calc(100% + 0.5rem);
    left: 0;
    right: 0;
    max-height: 14rem;
    overflow-y: auto;
    background: #fff;
    border: 1px solid rgba(74, 124, 89, 0.2);
    border-radius: 0.75rem;
    padding: 0.75rem;
    box-shadow: 0 10px 15px -3px rgba(42, 61, 52, 0.12), 0 4px 6px -2px rgba(42, 61, 52, 0.05);
    z-index: 20;
  }

  .filter-option + .filter-option {
    margin-top: 0.35rem;
  }

  .filter-checkbox {
    accent-color: #4A7C59;
  }
</style>
